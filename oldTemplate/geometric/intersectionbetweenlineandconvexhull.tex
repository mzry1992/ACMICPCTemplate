\subsection{直线与凸包求交点}
	复杂度$O(\log{n})$。\\
	需要先预处理几个东西。\\
	\begin{lstlisting}[language=c++]
//`二分[la,lb]这段区间那条边与line相交`
int Gao(int la,int lb,Line line)
{
	if (la > lb)
		lb += n;
	int l = la,r = lb,mid;
	while (l < r)
	{
		mid = l+r+1>>1;
		if (cmp((line.e-line.s)*(p[la]-line.s),0)*cmp((line.e-line.s)*(p[mid]-line.s),0) >= 0)
			l = mid;
		else
			r = mid-1;
	}
	return l%n;
}
//`求l与凸包的交点`

//`先调用Gettheta预处理出凸包每条边的斜率，然后处理成升序排列`
double theta[maxn];

void Gettheta()
{
	for (int i = 0;i < n;i++)
	{
		Point v = p[(i+1)%n]-p[i];
		theta[i] = atan2(v.y,v.x);
	}
	for (int i = 1;i < n;i++)
		if (theta[i-1] > theta[i]+eps)
			theta[i] += 2*pi;
}

double Calc(Line l)
{
	double tnow;
	Point v = l.e-l.s;
	tnow = atan2(v.y,v.x);
	if (cmp(tnow,theta[0]) < 0)	tnow += 2*pi;
	int pl = lower_bound(theta,theta+n,tnow)-theta;
	tnow = atan2(-v.y,-v.x);
	if (cmp(tnow,theta[0]) < 0)	tnow += 2*pi;
	int pr = lower_bound(theta,theta+n,tnow)-theta;
	//`pl和pr是在l方向上距离最远的点对`
	pl = pl%n;
	pr = pr%n;

	if (cmp(v*(p[pl]-l.s),0)*cmp(v*(p[pr]-l.s),0) >= 0)
		return 0.0;

	int xa = Gao(pl,pr,l);
	int xb = Gao(pr,pl,l);

	if (xa > xb)	swap(xa,xb);
	//`与[xa,xa+1]和[xb,xb+1]`这两条线段相交
	
	if (cmp(v*(p[xa+1]-p[xa]),0) == 0)  return 0.0;
	if (cmp(v*(p[xb+1]-p[xb]),0) == 0)  return 0.0;
	
	Point pa,pb;
	pa = Line(p[xa],p[xa+1])&l;
	pb = Line(p[xb],p[xb+1])&l;
	//`题目：求直线切凸包得到的两部分的面积`
	double area0 = sum[xb]-sum[xa+1]+(pa*p[xa+1])/2.0+(p[xb]*pb)/2.0+(pb*pa)/2.0;
	double area1 = sum[xa+n]-sum[xb+1]+(pb*p[xb+1])/2.0+(p[xa]*pa)/2.0+(pa*pb)/2.0;

	return min(area0,area1);
}
	\end{lstlisting}