struct Node
{
	int size, key;
	bool rev;

//	bool same;
//	int lsum, rsum, sum, maxsum, sa;

	Node *c[2];
	Node *p;
} mem[MaxN], *cur, *nil, *pos[MaxN];

Node *newNode(int v, Node *p)
{
	cur->c[0] = cur->c[1] = nil, cur->p = p;
	cur->size = 1;
	cur->key = v;
	cur->rev = false;

//	cur->same = false;
//	cur->sa = 0;
//	cur->lsum = cur->rsum = cur->maxsum = 0;
//	cur->sum = v;

	return cur++;
}

void Init()
{
	cur = mem;
	nil = newNode(0, cur);
	nil->size = 0;
}

struct SplayTree
{
	void Pushup(Node *x)
	{
		if (x == nil)   return;
		Pushdown(x); Pushdown(x->c[0]); Pushdown(x->c[1]);
		x->size = x->c[0]->size + x->c[1]->size + 1;

//		x->sum = x->c[0]->sum + x->c[1]->sum + x->key;
//		x->lsum = max(x->c[0]->lsum, 
//			x->c[0]->sum + x->key + max(0, x->c[1]->lsum));
//		x->rsum = max(x->c[1]->rsum, 
//			x->c[1]->sum + x->key + max(0, x->c[0]->rsum));
//		x->maxsum = max(max(x->c[0]->maxsum, x->c[1]->maxsum),
//			x->key + max(0, x->c[0]->rsum) + max(0, x->c[1]->lsum));

	}
	void Pushdown(Node *x)
	{
		if (x == nil)   return;
		if (x->rev)
		{
			x->rev = 0;
			x->c[0]->rev ^= 1;
			x->c[1]->rev ^= 1;
			swap(x->c[0], x->c[1]);
//			swap(x->lsum,x->rsum);
		}

//		if (x->same)
//		{
//			x->same = false;
//			x->key = x->sa;
//			x->sum = x->sa * x->size;
//			x->lsum = x->rsum = x->maxsum = max(0, x->sum);
//			if (x->c[0] != nil)
//				x->c[0]->same = true, x->c[0]->sa = x->sa;
//			if (x->c[1] != nil)
//				x->c[1]->same = true, x->c[1]->sa = x->sa;
//		}
	}
	bool isRoot(Node *x)
	{
		return (x == nil) || (x->p->c[0] != x && x->p->c[1] != x);
	}
	void Rotate(Node *x, int f)
	{
		if (isRoot(x))   return;
		Node *y = x->p;
		y->c[f ^ 1] = x->c[f], x->p = y->p;
		if (x->c[f] != nil)
			x->c[f]->p = y;
		if (y != nil)
		{
			if (y == y->p->c[1])
				y->p->c[1] = x;
			else if (y == y->p->c[0])
				y->p->c[0] = x;
		}
		x->c[f] = y, y->p = x;
		Pushup(y);
	}
	void Splay(Node *x)
	{
		static Node *stack[MaxN];
		int top = 0;
		stack[top++] = x;
		for (Node *y = x; !isRoot(y); y = y->p)
			stack[top++] = y->p;
		while (top)
			Pushdown(stack[--top]);

		while (!isRoot(x))
		{
			Node *y = x->p;
			if (isRoot(y))
				Rotate(x, x == y->c[0]);
			else
			{
				int fd = y->p->c[0] == y;
				if (y->c[fd] == x)
					Rotate(x, fd ^ 1), Rotate(x, fd);
				else
					Rotate(y, fd), Rotate(x, fd);
			}
		}
		Pushup(x);
	}
	Node *Access(Node *u)
	{
		Node *v = nil;
		while (u != nil)
		{
			Splay(u);
			v->p = u;
			u->c[1] = v;
			Pushup(u);
			u = (v = u)->p;
			if (u == nil)
				return v;
		}
	}
	Node *LCA(Node *u, Node *v)
	{
		Access(u);
		return Access(v);
	}
	Node *Link(Node *u, Node *v)
	{
		Access(u);
		Splay(u);
		u->rev = true;
		u->p = v;
	}
	void ChangeRoot(Node *u)
	{
		Access(u)->rev ^= 1;
	}
	Node *GetRoute(Node *u, Node *v)
	{
		ChangeRoot(u);
		return Access(v);
	}
};

int n, m;
SplayTree sp;

int main(int argc, char const *argv[])
{
	while (scanf("%d", &n) != EOF)
	{
		Init();
		for (int i = 0; i < n; i++)
		{
			int v;
			scanf("%d", &v);
			pos[i] = newNode(v, nil);
		}
		for (int i = 0; i < n - 1; i++)
		{
			int u, v;
			scanf("%d%d", &u, &v);
			u--, v--;
			sp.Link(pos[u], pos[v]);
		}

//		scanf("%d", &m);
//		for (int i = 0; i < m; i++)
//		{
//			int typ, u, v, c;
//			scanf("%d%d%d", &typ, &u, &v);
//			u--, v--;
//			if (typ == 1)
//				printf("%d\n", sp.GetRoute(pos[u], pos[v])->maxsum);
//			else
//			{
//				scanf("%d", &c);
//				Node *p = sp.GetRoute(pos[u], pos[v]);
//				p->same = true;
//				p->sa = c;
//			}
//		}
	}
	return 0;
}
